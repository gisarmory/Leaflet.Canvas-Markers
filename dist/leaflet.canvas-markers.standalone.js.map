{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/plugin/leaflet.canvas-markers.js","webpack:///./src/_standalone.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;AClFA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA,SAAS;;AAET;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;;AAEA;AACA;AACA,SAAS;;AAET;;AAEA;AACA,SAAS;;AAET;;AAEA;AACA,SAAS;;AAET;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,SAAS;;AAET;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,4CAA4C,qCAAqC;;AAEjF;;AAEA;;AAEA;;AAEA;AACA;;AAEA,sEAAsE,sBAAsB,EAAE;AAC9F;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sEAAsE,sBAAsB,EAAE;AAC9F;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;;;;;;;AChcA;;AAEA","file":"leaflet.canvas-markers.standalone.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","'use strict';\r\n\r\nfunction layerFactory(L) {\r\n\r\n    var CanvasIconLayer = (L.Layer ? L.Layer : L.Class).extend({\r\n\r\n        //Add event listeners to initialized section.\r\n        initialize: function (options) {\r\n\r\n            L.setOptions(this, options);\r\n            this._onClickListeners = [];\r\n            this._onHoverListeners = [];\r\n        },\r\n\r\n        setOptions: function (options) {\r\n\r\n            L.setOptions(this, options);\r\n            return this.redraw();\r\n        },\r\n\r\n        redraw: function () {\r\n\r\n            this._redraw(true);\r\n        },\r\n\r\n        //Multiple layers at a time for rBush performance\r\n        addMarkers: function (markers) {\r\n\r\n            var self = this;\r\n            var tmpMark = [];\r\n            var tmpLatLng = [];\r\n\r\n            markers.forEach(function (marker) {\r\n\r\n                if (!((marker.options.pane == 'markerPane') && marker.options.icon))\r\n                {\r\n                    console.error('Layer isn\\'t a marker');\r\n                    return;\r\n                }\r\n\r\n                var latlng = marker.getLatLng();\r\n                var isDisplaying = self._map.getBounds().contains(latlng);\r\n                var s = self._addMarker(marker,latlng,isDisplaying);\r\n\r\n                //Only add to Point Lookup if we are on map\r\n                if (isDisplaying ===true) tmpMark.push(s[0]);\r\n\r\n                tmpLatLng.push(s[1]);\r\n            });\r\n\r\n            self._markers.load(tmpMark);\r\n            self._latlngMarkers.load(tmpLatLng);\r\n        },\r\n\r\n        //Adds single layer at a time. Less efficient for rBush\r\n        addMarker: function (marker) {\r\n\r\n            var self = this;\r\n            var latlng = marker.getLatLng();\r\n            var isDisplaying = self._map.getBounds().contains(latlng);\r\n            var dat = self._addMarker(marker,latlng,isDisplaying);\r\n\r\n            //Only add to Point Lookup if we are on map\r\n            if(isDisplaying ===true) self._markers.insert(dat[0]);\r\n\r\n            self._latlngMarkers.insert(dat[1]);\r\n        },\r\n\r\n        addLayer: function (layer) {\r\n\r\n            if ((layer.options.pane == 'markerPane') && layer.options.icon) this.addMarker(layer);\r\n            else console.error('Layer isn\\'t a marker');\r\n        },\r\n\r\n        addLayers: function (layers) {\r\n\r\n            this.addMarkers(layers);\r\n        },\r\n\r\n        removeLayer: function (layer) {\r\n\r\n            this.removeMarker(layer,true);\r\n        },\r\n\r\n        removeMarker: function (marker,redraw) {\r\n\r\n            var self = this;\r\n\r\n            //If we are removed point\r\n            if(marker[\"minX\"]) marker = marker.data;\r\n\r\n            var latlng = marker.getLatLng();\r\n            var isDisplaying = self._map.getBounds().contains(latlng);\r\n\r\n            var markerData = {\r\n\r\n                minX: latlng.lng,\r\n                minY: latlng.lat,\r\n                maxX: latlng.lng,\r\n                maxY: latlng.lat,\r\n                data: marker\r\n            };\r\n\r\n            self._latlngMarkers.remove(markerData, function (a,b) {\r\n\r\n                return a.data._leaflet_id ===b.data._leaflet_id;\r\n            });\r\n\r\n            self._latlngMarkers.total--;\r\n            self._latlngMarkers.dirty++;\r\n\r\n            if(isDisplaying ===true && redraw ===true) {\r\n\r\n                self._redraw(true);\r\n            }\r\n        },\r\n\r\n        onAdd: function (map) {\r\n\r\n            this._map = map;\r\n\r\n            if (!this._canvas) this._initCanvas();\r\n\r\n            if (this.options.pane) this.getPane().appendChild(this._canvas);\r\n            else map._panes.overlayPane.appendChild(this._canvas);\r\n\r\n            map.on('moveend', this._reset, this);\r\n            map.on('resize',this._reset,this);\r\n\r\n            map.on('click', this._executeListeners, this);\r\n            map.on('mousemove', this._executeListeners, this);\r\n\r\n            if (map._zoomAnimated) {\r\n                map.on('zoomanim', this._animateZoom, this);\r\n            }\r\n        },\r\n\r\n        onRemove: function (map) {\r\n\r\n            if (this.options.pane) this.getPane().removeChild(this._canvas);\r\n            else map.getPanes().overlayPane.removeChild(this._canvas);\r\n\r\n            map.off('click', this._executeListeners, this);\r\n            map.off('mousemove', this._executeListeners, this);\r\n\r\n            map.off('moveend', this._reset, this);\r\n            map.off('resize',this._reset,this);\r\n\r\n\r\n            if (map._zoomAnimated) {\r\n                map.off('zoomanim', this._animateZoom, this);\r\n            }\r\n        },\r\n\r\n        addTo: function (map) {\r\n\r\n            map.addLayer(this);\r\n            return this;\r\n        },\r\n\r\n        clearLayers: function() {\r\n\r\n            this._latlngMarkers = null;\r\n            this._markers = null;\r\n            this._redraw(true);\r\n        },\r\n\r\n        _animateZoom: function(event) {\r\n            var scale = this._map.getZoomScale(event.zoom);\r\n            var offset = this._map._latLngBoundsToNewLayerBounds(this._map.getBounds(), event.zoom, event.center).min;\r\n\r\n            L.DomUtil.setTransform(this._canvas, offset, scale);\r\n        },\r\n\r\n        _addMarker: function(marker,latlng,isDisplaying) {\r\n\r\n            var self = this;\r\n            //Needed for pop-up & tooltip to work.\r\n            marker._map = self._map;\r\n\r\n            //_markers contains Points of markers currently displaying on map\r\n            if (!self._markers) self._markers = new rbush();\r\n\r\n            //_latlngMarkers contains Lat\\Long coordinates of all markers in layer.\r\n            if (!self._latlngMarkers) {\r\n                self._latlngMarkers = new rbush();\r\n                self._latlngMarkers.dirty=0;\r\n                self._latlngMarkers.total=0;\r\n            }\r\n\r\n            L.Util.stamp(marker);\r\n\r\n            var pointPos = self._map.latLngToContainerPoint(latlng);\r\n            var iconSize = marker.options.icon.options.iconSize;\r\n\r\n            var adj_x = iconSize[0]/2;\r\n            var adj_y = iconSize[1]/2;\r\n            var ret = [({\r\n                minX: (pointPos.x - adj_x),\r\n                minY: (pointPos.y - adj_y),\r\n                maxX: (pointPos.x + adj_x),\r\n                maxY: (pointPos.y + adj_y),\r\n                data: marker\r\n            }),({\r\n                minX: latlng.lng,\r\n                minY: latlng.lat,\r\n                maxX: latlng.lng,\r\n                maxY: latlng.lat,\r\n                data: marker\r\n            })];\r\n\r\n            self._latlngMarkers.dirty++;\r\n            self._latlngMarkers.total++;\r\n\r\n            //Only draw if we are on map\r\n            if(isDisplaying===true) self._drawMarker(marker, pointPos);\r\n\r\n            return ret;\r\n        },\r\n\r\n        _drawMarker: function (marker, pointPos) {\r\n\r\n            var self = this;\r\n\r\n            if (!this._imageLookup) this._imageLookup = {};\r\n            if (!pointPos) {\r\n\r\n                pointPos = self._map.latLngToContainerPoint(marker.getLatLng());\r\n            }\r\n\r\n            var iconUrl = marker.options.icon.options.iconUrl;\r\n\r\n            if (marker.canvas_img) {\r\n\r\n                self._drawImage(marker, pointPos);\r\n            }\r\n            else {\r\n\r\n                if(self._imageLookup[iconUrl]) {\r\n\r\n                    marker.canvas_img = self._imageLookup[iconUrl][0];\r\n\r\n                    if (self._imageLookup[iconUrl][1] ===false) {\r\n\r\n                        self._imageLookup[iconUrl][2].push([marker,pointPos]);\r\n                    }\r\n                    else {\r\n\r\n                        self._drawImage(marker,pointPos);\r\n                    }\r\n                }\r\n                else {\r\n\r\n                    var i = new Image();\r\n                    i.src = iconUrl;\r\n                    marker.canvas_img = i;\r\n\r\n                    //Image,isLoaded,marker\\pointPos ref\r\n                    self._imageLookup[iconUrl] = [i, false, [[marker, pointPos]]];\r\n\r\n                    i.onload = function() {\r\n\r\n                        self._imageLookup[iconUrl][1] = true;\r\n                        self._imageLookup[iconUrl][2].forEach(function (e) {\r\n\r\n                            self._drawImage(e[0],e[1]);\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        _drawImage: function (marker, pointPos) {\r\n\r\n            var options = marker.options.icon.options;\r\n\r\n            this._context.drawImage(\r\n                marker.canvas_img,\r\n                pointPos.x - options.iconAnchor[0],\r\n                pointPos.y - options.iconAnchor[1],\r\n                options.iconSize[0],\r\n                options.iconSize[1]\r\n            );\r\n\r\n            this._context.fillText(\r\n                'ttttttt',\r\n                pointPos.x ,\r\n                pointPos.y,\r\n            );\r\n        },\r\n\r\n        // _drawText: function (marker, pointPos){\r\n\r\n        //     var options = marker.options.icon.options;\r\n\r\n        //     this._context.fillText(\r\n\r\n        //     );\r\n        // }\r\n\r\n        _reset: function () {\r\n\r\n            var topLeft = this._map.containerPointToLayerPoint([0, 0]);\r\n            L.DomUtil.setPosition(this._canvas, topLeft);\r\n\r\n            var size = this._map.getSize();\r\n\r\n            this._canvas.width = size.x;\r\n            this._canvas.height = size.y;\r\n\r\n            this._redraw();\r\n        },\r\n\r\n        _redraw: function (clear) {\r\n\r\n            var self = this;\r\n\r\n            if (clear) this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);\r\n            if (!this._map || !this._latlngMarkers) return;\r\n\r\n            var tmp = [];\r\n\r\n            //If we are 10% individual inserts\\removals, reconstruct lookup for efficiency\r\n            if (self._latlngMarkers.dirty/self._latlngMarkers.total >= .1) {\r\n\r\n                self._latlngMarkers.all().forEach(function(e) {\r\n\r\n                    tmp.push(e);\r\n                });\r\n\r\n                self._latlngMarkers.clear();\r\n                self._latlngMarkers.load(tmp);\r\n                self._latlngMarkers.dirty=0;\r\n                tmp = [];\r\n            }\r\n\r\n            var mapBounds = self._map.getBounds();\r\n\r\n            //Only re-draw what we are showing on the map.\r\n\r\n            var mapBoxCoords = {\r\n\r\n                minX: mapBounds.getWest(),\r\n                minY: mapBounds.getSouth(),\r\n                maxX: mapBounds.getEast(),\r\n                maxY: mapBounds.getNorth(),\r\n            };\r\n\r\n            self._latlngMarkers.search(mapBoxCoords).forEach(function (e) {\r\n\r\n                //Readjust Point Map\r\n                var pointPos = self._map.latLngToContainerPoint(e.data.getLatLng());\r\n\r\n                var iconSize = e.data.options.icon.options.iconSize;\r\n                var adj_x = iconSize[0]/2;\r\n                var adj_y = iconSize[1]/2;\r\n\r\n                var newCoords = {\r\n                    minX: (pointPos.x - adj_x),\r\n                    minY: (pointPos.y - adj_y),\r\n                    maxX: (pointPos.x + adj_x),\r\n                    maxY: (pointPos.y + adj_y),\r\n                    data: e.data\r\n                }\r\n\r\n                tmp.push(newCoords);\r\n\r\n                //Redraw points\r\n                self._drawMarker(e.data, pointPos);\r\n            });\r\n\r\n            //Clear rBush & Bulk Load for performance\r\n            this._markers.clear();\r\n            this._markers.load(tmp);\r\n        },\r\n\r\n        _initCanvas: function () {\r\n\r\n            this._canvas = L.DomUtil.create('canvas', 'leaflet-canvas-icon-layer leaflet-layer');\r\n\r\n            var size = this._map.getSize();\r\n            this._canvas.width = size.x;\r\n            this._canvas.height = size.y;\r\n\r\n            this._context = this._canvas.getContext('2d');\r\n\r\n            var animated = this._map.options.zoomAnimation && L.Browser.any3d;\r\n            L.DomUtil.addClass(this._canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));\r\n        },\r\n\r\n        addOnClickListener: function (listener) {\r\n            this._onClickListeners.push(listener);\r\n        },\r\n\r\n        addOnHoverListener: function (listener) {\r\n            this._onHoverListeners.push(listener);\r\n        },\r\n\r\n        _executeListeners: function (event) {\r\n\r\n            if (!this._markers) return;\r\n\r\n            var me = this;\r\n            var x = event.containerPoint.x;\r\n            var y = event.containerPoint.y;\r\n\r\n            if(me._openToolTip) {\r\n\r\n                me._openToolTip.closeTooltip();\r\n                delete me._openToolTip;\r\n            }\r\n\r\n            var ret = this._markers.search({ minX: x, minY: y, maxX: x, maxY: y });\r\n\r\n            if (ret && ret.length > 0) {\r\n\r\n                me._map._container.style.cursor=\"pointer\";\r\n\r\n                if (event.type===\"click\") {\r\n\r\n                    var hasPopup = ret[0].data.getPopup();\r\n                    if(hasPopup) ret[0].data.openPopup();\r\n\r\n                    me._onClickListeners.forEach(function (listener) { listener(event, ret); });\r\n                }\r\n\r\n                if (event.type===\"mousemove\") {\r\n                    var hasTooltip = ret[0].data.getTooltip();\r\n                    if(hasTooltip) {\r\n                        me._openToolTip = ret[0].data;\r\n                        ret[0].data.openTooltip();\r\n                    }\r\n\r\n                    me._onHoverListeners.forEach(function (listener) { listener(event, ret); });\r\n                }\r\n            }\r\n            else {\r\n\r\n                me._map._container.style.cursor=\"\";\r\n            }\r\n        }\r\n    });\r\n\r\n    L.canvasIconLayer = function (options) {\r\n        return new CanvasIconLayer(options);\r\n    };\r\n};\r\n\r\nmodule.exports = layerFactory;\r\n","var factory = require(\"./plugin/leaflet.canvas-markers\");\r\n\r\nwindow.L.CanvasIconLayer = factory(L);\r\n"],"sourceRoot":""}